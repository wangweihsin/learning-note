# Merge Sort 合併排序法

概念:將大的問題分解成很多個小問題，從小的問題開始解決起。把小事解決完以後合併回大問題，大問題自然就解決了。

## 流程圖

![MergeSort](https://github.com/wangweihsin/learning-note/blob/master/%E5%9C%96%E7%89%87/MergeSort%E6%B5%81%E7%A8%8B%E5%9C%96.jpg?raw=true)

# 過程

Merge Sorty主要步驟就是1.拆分2.合併

- 分解

將list從中間切一半分成兩個小list

大--->中--->小

一直對半分，直到list中只剩一個元素沒辦法再分成兩個list為止。

- 合併

左右兩個list比較排序 從各自的第一個數字開始排序 比較大的就先放到list裡

兩兩比較直到某個list裡的數字先沒了 剩下那個list的數字就可以直接放下去

ex:[10,17] [2,32,65] 2跟10比2先放下去 接個10跟32比10放下去 17跟32比17放下去

[2,10,17,_ ,_ ]<--變成這樣

此時左邊的list已經空了 右邊剩[32,65]就可以直接放下去

因為前面已經排序過了!

# Heap Sort 堆積排序法

概念:像樹狀圖一樣，每個父母下面有兩個孩子，最底層可以有缺(只有一個或沒有)。父母必須比子女大(小)，最上層的父母最大(小)。

1.max heap(最大堆積)

最上層的數字(root)必大於下面所有數

2.min heap(最小堆積)

最上層的數字(root)必小於下面所有數

# 流程圖

![流程圖](https://github.com/wangweihsin/learning-note/blob/master/%E5%9C%96%E7%89%87/Heapsort%E6%B5%81%E7%A8%8B%E5%9C%96.jpg?raw=true)

# 過程

以下用max heap來說明排序過程

將list中的元素從最上方一路放下來後 由左至右 子節永遠小於父節

一但孩子比父母大 就往上移動 這樣一來最大的值就會在最上方

將最上方(最大值)拿掉 把最下方的孩子拿到第一個重新排序

不斷重複
